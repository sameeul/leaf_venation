#This script uses the blade part and vein part generated by 
#script CreateModel.py to repair in selected vein segments
#so that the resemble more realistic vein structure
#The modified leaf part and vein part definition are saved
#as inp files


#Algorithm for function min_distance3d(edge1,edge2)was adopted
#from SoftSurfer.com/ Algorithm 7
#http://softsurfer.com/Archive/algorithm_0106/algorithm_0106.htm [39]

import pickle
import math
import os
path="Z:/Documents/Dropbox/MSME/thesis/abaqus_temp/"


def distance_p2p(loc1,loc2):    
    return math.sqrt((loc1[0]-loc2[0])**2+(loc1[1]-loc2[1])**2+(loc1[2]-loc2[2])**2)



def min_distance3d(edge1,edge2):
#finds minimum distance between two edges
#We want to find the w(s,t) that has a minimum length for all s and t. 

    eps= 1e-8
    loc1=edge1[0]
    loc2=edge1[1]
    loc3=edge2[0]
    loc4=edge2[1]
    
    u=[loc2[0]-loc1[0],loc2[1]-loc1[1],loc2[2]-loc1[2]]
    v=[loc4[0]-loc3[0],loc4[1]-loc3[1],loc4[2]-loc3[2]]
    w=[loc1[0]-loc3[0],loc1[1]-loc3[1],loc1[2]-loc3[2]]
    
    a=u[0]*u[0]+u[1]*u[1]+u[2]*u[2]
    b=u[0]*v[0]+u[1]*v[1]+u[2]*v[2]
    c=v[0]*v[0]+v[1]*v[1]+v[2]*v[2]
    d=u[0]*w[0]+u[1]*w[1]+u[2]*w[2]
    e=v[0]*w[0]+v[1]*w[1]+v[2]*w[2]
    D=(a*c-b*b)
    sc=D
    sN=D
    sD=D
    tc=D
    tN=D
    tD=D
    
    if (D < eps): 
        sN = 0.0    
        sD = 1.0        
        tN = e
        tD = c
    
    else:

        sN = (b*e - c*d)
        tN = (a*e - b*d)
        if (sN < 0.0):
            sN = 0.0
            tN = e
            tD = c
        elif (sN > sD):
            sN = sD
            tN = e + b
            tD = c
        
    if (tN < 0.0):
        tN = 0.0
        if (-d < 0.0):
            sN = 0.0
        elif (-d > a):
            sN = sD
        else:
            sN = -d
            sD = a

    elif (tN > tD): 
        tN = tD
        if ((-d + b) < 0.0):
            sN = 0
        elif ((-d + b) > a):
            sN = sD
        else:
            sN = (-d + b)
            sD = a

    if (abs(sN) < eps):
        sc=0.0
    else:
        sc=sN/sD
    
    if (abs(tN) < eps):
        tc=0.0
    else:
        tc=tN/tD
# returns tc (between 0 and 1, and location of tc)
    return tc,(loc3[0]+tc*v[0],loc3[1]+tc*v[1],loc3[2]+tc*v[2])

 




def create_new_blade():
# writes an Abaqus input file for blade
#    global elements, nodes

    g=open(path+"blade.inp", 'wt')

    nodes=pickle.load(open( path+"node_data", "rb" ))  
    elements=pickle.load(open( path+"element_data", "rb" )) 
    
    
    g.write("*Heading")
    g.write(os.linesep)
    g.write("** Job name: blade Model name: Model-blade")
    g.write(os.linesep)
    g.write("*Preprint, echo=NO, model=NO, history=NO, contact=NO")
    g.write(os.linesep)
    g.write("**")
    g.write(os.linesep)
    g.write("** PARTS")
    g.write(os.linesep)
    g.write("**")
    g.write(os.linesep)
    g.write("*Part, name=blade_alone")
    g.write(os.linesep)
    g.write("*Node") 
    g.write(os.linesep)

    i=1
    for node in nodes:
        #print node
        line=str(i)+", "+str(node[0])+", "+str(node[1])+", "+str(node[2])
        #print line
        g.write(line)
        g.write(os.linesep)
        i=i+1
    
    g.write("*Element, type=S4R")
    g.write(os.linesep)
    elements3=[]
    for element in elements:
        if len(element)==4:
            line=str(elements.index(element)+1)+", "+str(element[0]+1)+", "+str(element[1]+1)+", "+str(element[2]+1)+", "+str(element[3]+1)
            g.write(line)
            g.write(os.linesep)
        else:
            elements3.append(element)
     
    g.write("*Element, type=S3")
    g.write(os.linesep)        
    for element in elements3:
        if len(element)==3:
            line=str(elements.index(element)+1)+", "+str(element[0]+1)+", "+str(element[1]+1)+", "+str(element[2]+1)
            g.write(line)
            g.write(os.linesep)
    
    g.write("*End Part")
    g.write(os.linesep)
    g.write("**")  
    g.write(os.linesep)
    g.write("**")
    g.write(os.linesep)
    g.write("** ASSEMBLY")
    g.write(os.linesep)
    g.write("**")
    g.write(os.linesep)
    g.write("*Assembly, name=Assembly")
    g.write(os.linesep)
    g.write("**")  
    g.write(os.linesep)
    g.write("*Instance, name=blade_alone-1, part=blade_alone")
    g.write(os.linesep)
    g.write("*End Instance")
    g.write(os.linesep)
    g.write("**")  
    g.close()

def make_vein(vein_segments):
#writes an Abaqus input file for vein

    check=[]
    g=open(path+"vein_mesh.inp", 'wt')
    
    
    g.write("*Heading")
    g.write(os.linesep)
    g.write("** Job name: vein_mesh Model name: Model-Vein")
    g.write(os.linesep)
    g.write("*Preprint, echo=NO, model=NO, history=NO, contact=NO")
    g.write(os.linesep)
    g.write("**")
    g.write(os.linesep)
    g.write("** PARTS")
    g.write(os.linesep)
    g.write("**")
    g.write(os.linesep)
    g.write("*Part, name=vein")
    g.write(os.linesep)
    g.write("*Node") 
    g.write(os.linesep)
    i=1
    
    for vein_segment in vein_segments:
        for node in vein_segment:
            if node in check:
                pass
            else:
                line=str(i)+", "+str(node[0])+", "+str(node[1])+", "+str(node[2])
                g.write(line)
                g.write(os.linesep)
                i=i+1
                check.append(node)
    
    g.write("*Element, type=B33")
    g.write(os.linesep)
    
    j=1
    for vein_segment in vein_segments:
        for i in range(0,len(vein_segment)-1):       
            line=str(j)+", "+str(check.index(vein_segment[i])+1)+", "+str(check.index(vein_segment[i+1])+1)
            g.write(line)
            g.write(os.linesep)
            j=j+1

     
    g.write("*End Part")
    g.write(os.linesep)
    g.write("**")  
    g.write(os.linesep)
    g.write("**")
    g.write(os.linesep)
    g.write("** ASSEMBLY")
    g.write(os.linesep)
    g.write("**")
    g.write(os.linesep)
    g.write("*Assembly, name=Assembly")
    g.write(os.linesep)
    g.write("**")  
    g.write(os.linesep)
    g.write("*Instance, name=vein-1, part=vein")
    g.write(os.linesep)
    g.write("*End Instance")
    g.write(os.linesep)
    g.write("**")  
    g.close()


def repair_vein(start_node, end_node):

    nodes=pickle.load(open( path+"node_data", "rb" ))
    veins=pickle.load(open( path+"vein_data", "rb" ))   
    vein_structures=pickle.load(open( path+"point_list", "rb" ))  
    elements=pickle.load(open( path+"element_data", "rb" ))
    nodes=list(nodes)     
    
    node_coordinate=[]
    check_list=[]

    node_coordinate.append(nodes[start_node-1])
    n1=nodes[start_node-1]
    n2=nodes[end_node-1]
    
    #print vein_structures
    des_vein=[]
    for vein_structure in vein_structures:
        if n1 in vein_structure and n2 in vein_structure:
            mark=vein_structures.index(vein_structure)
            des_vein=vein_structure    
            break # found vein to edit


#split between start and end node
    t1= des_vein.index(n1)
    t2= des_vein.index(n2)

    des_vein_part_1=des_vein[0:t1]
    des_vein_part_2=des_vein[t2+1:]

#refine    
    while distance_p2p(n1,n2)>1e-6:
        
        x=[None]*3

        a=n1
        b=n2
        node1=nodes.index(n1)+1
        node2=nodes.index(n2)+1

        neighbor1=[]
#find neighbor elements        
        for element in elements:
            if node1-1 in element:
                if elements.index(element)+1 in check_list:
                    pass
                else:
                    neighbor1.append(elements.index(element)+1)

        t=[]
        for i in neighbor1:
            s=0
            points=elements[i-1] #list of points in the element
            for j in points:
                x[0]=nodes[j][0]
                x[1]=nodes[j][1]
                x[2]=nodes[j][2]
                s=s+distance_p2p(a,x)+distance_p2p(b,x)
                
            t.append(s)   

#find the closest element from the node
        min_dist=min(t)
        k=neighbor1[t.index(min_dist)]

        check_list.append(k)
        node_list=elements[k-1]
        edge_list=[]

# create a list of edges from the closest element
        for i in range (0, len(node_list)-1):
            if node_list[i]!=node1-1 and node_list[i+1]!=node1-1:
                edge_list.append((node_list[i]+1,node_list[i+1]+1))
        
        if node_list[-1]!=node1-1 and node_list[0]!=node1-1:
            edge_list.append((node_list[-1]+1,node_list[0]+1))

        t=[]

#find the closest edge to line created by node1 and end_node
        for edge in edge_list:
            loc1=nodes[edge[0]-1]
            loc2=nodes[edge[1]-1]
            loc=[None]*3
            loc=[(loc1[0]+loc2[0])/2,(loc1[1]+loc2[1])/2,(loc1[2]+loc2[2])/2]
            s=distance_p2p(loc, a)+distance_p2p(loc, b)
            t.append(s)    
        min_dist=min(t)
        dis_edge=edge_list[t.index(min_dist)]
        e1=[nodes[node1-1],nodes[end_node-1]]
        e2=[nodes[dis_edge[0]-1],nodes[dis_edge[1]-1]]
#find closest point on the closest edge
        t,n=min_distance3d(e1,e2)
        
        #checks if displacing the node a little bit is sufficinet
        if t<=0.2:
            nodes[dis_edge[0]-1]=n
        elif t>0.8:
            nodes[dis_edge[1]-1]=n        
        else:#if not
            #create new node and elements
            
            #create new node to the nodes list
            nodes.append(n)
            #sort the nodes in the element conncetivity
            if len(node_list)==4: #if its a S4 element
                k1=node_list.index(dis_edge[0]-1)
                k2=node_list.index(dis_edge[1]-1)
                new_sorted_list=[]
                new_sorted_list.append(dis_edge[0]-1)
                new_sorted_list.append(dis_edge[1]-1)
                while len(new_sorted_list)<len(node_list):
                    if k2<len(node_list)-1: 
                        new_sorted_list.append(node_list[k2+1])
                        k2=k2+1

                    else:
                        new_sorted_list.append(node_list[0])
                        k2=0
                                
                #come up with 3 new element connectivity for the current element
                elements[k-1]= (len(nodes)-1,new_sorted_list[1],new_sorted_list[2])
                elements.append((new_sorted_list[2],new_sorted_list[3],len(nodes)-1))
                elements.append((new_sorted_list[3],new_sorted_list[0],len(nodes)-1))
                
                print (len(nodes)-1,new_sorted_list[1],new_sorted_list[2])
                print (new_sorted_list[2],new_sorted_list[3],len(nodes)-1)
                print (new_sorted_list[3],new_sorted_list[0],len(nodes)-1)
            
            
                #come up with 3 new element connectivity for the neighbour element
                for element in elements:
                    if (dis_edge[0]-1) in element and (dis_edge[1]-1) in element:
                        neighbor_element=elements.index(element)
                        print neighbor_element
                        break
                
                node_list=elements[neighbor_element]
                dis_edge_rev=(dis_edge[1],dis_edge[0]) #change the direction of the edge for the neighbor element
                if len(node_list)==4: #if its a S4 element
                    k1=node_list.index(dis_edge_rev[0]-1)
                    k2=node_list.index(dis_edge_rev[1]-1)
                    new_sorted_list=[]
                    new_sorted_list.append(dis_edge_rev[0]-1)
                    new_sorted_list.append(dis_edge_rev[1]-1)
                    while len(new_sorted_list)<len(node_list):
                        if k2<len(node_list)-1: 
                            new_sorted_list.append(node_list[k2+1])
                            k2=k2+1
                        else:
                            new_sorted_list.append(node_list[0])
                            k2=0

                #come up with 3 new element connectivity for the current element
                    elements[neighbor_element]=(len(nodes)-1,new_sorted_list[1],new_sorted_list[2])
                    elements.append((new_sorted_list[2],new_sorted_list[3],len(nodes)-1))
                    elements.append((new_sorted_list[3],new_sorted_list[0],len(nodes)-1))
                    
                    print (len(nodes)-1,new_sorted_list[1],new_sorted_list[2])
                    print (new_sorted_list[2],new_sorted_list[3],len(nodes)-1)
                    print (new_sorted_list[3],new_sorted_list[0],len(nodes)-1)
            
                elif len(node_list)==3: #if its a S3 element
                    k1=node_list.index(dis_edge_rev[0]-1)
                    k2=node_list.index(dis_edge_rev[1]-1)
                    new_sorted_list=[]
                    new_sorted_list.append(dis_edge_rev[0]-1)
                    new_sorted_list.append(dis_edge_rev[1]-1)
                    while len(new_sorted_list)<len(node_list):
                        if k2<len(node_list)-1: 
                            new_sorted_list.append(node_list[k2+1])
                            k2=k2+1
                        else:
                            new_sorted_list.append(node_list[0])
                            k2=0

                #come up with 2 new element connectivity for the current element
                    elements[neighbor_element]=(len(nodes)-1,new_sorted_list[1],new_sorted_list[2])
                    elements.append((new_sorted_list[2],new_sorted_list[0],len(nodes)-1))
                    
                    print (len(nodes)-1,new_sorted_list[1],new_sorted_list[2])
                    print (new_sorted_list[2],new_sorted_list[0],len(nodes)-1)
                    
                else:
                    print "Seems the element is invalid!"
            
            elif len(node_list)==3: #if its a S3 element
                k1=node_list.index(dis_edge[0]-1)
                k2=node_list.index(dis_edge[1]-1)
                new_sorted_list=[]
                new_sorted_list.append(dis_edge[0]-1)
                new_sorted_list.append(dis_edge[1]-1)

                

                while len(new_sorted_list)<len(node_list):
                    if k2<len(node_list)-1: 
                        new_sorted_list.append(node_list[k2+1])
                        k2=k2+1

                    else:
                        new_sorted_list.append(node_list[0])
                        k2=0


                #come up with 2 new element connectivity for the current element
                elements[k-1]= (len(nodes)-1,new_sorted_list[1],new_sorted_list[2])
                elements.append((new_sorted_list[2],new_sorted_list[0],len(nodes)-1))
                
                print (len(nodes)-1,new_sorted_list[1],new_sorted_list[2])
                print (new_sorted_list[2],new_sorted_list[0],len(nodes)-1)
            
            
                #come up with 3 new element connectivity for the neighbour element
                for element in elements:
                    if (dis_edge[0]-1) in element and (dis_edge[1]-1) in element:
                        neighbor_element=elements.index(element)
                        print neighbor_element
                        break
                
                node_list=elements[neighbor_element]
                dis_edge_rev=(dis_edge[1],dis_edge[0]) #change the direction of the edge for the neighbor element
                if len(node_list)==4: #if its a S4 element
                    k1=node_list.index(dis_edge_rev[0]-1)
                    k2=node_list.index(dis_edge_rev[1]-1)
                    new_sorted_list=[]
                    new_sorted_list.append(dis_edge_rev[0]-1)
                    new_sorted_list.append(dis_edge_rev[1]-1)
                    while len(new_sorted_list)<len(node_list):
                        if k2<len(node_list)-1: 
                            new_sorted_list.append(node_list[k2+1])
                            k2=k2+1
                        else:
                            new_sorted_list.append(node_list[0])
                            k2=0

                #come up with 3 new element connectivity for the current element
                    elements[neighbor_element]=(len(nodes)-1,new_sorted_list[1],new_sorted_list[2])
                    elements.append((new_sorted_list[2],new_sorted_list[3],len(nodes)-1))
                    elements.append((new_sorted_list[3],new_sorted_list[0],len(nodes)-1))
                    
                    print (len(nodes)-1,new_sorted_list[1],new_sorted_list[2])
                    print (new_sorted_list[2],new_sorted_list[3],len(nodes)-1)
                    print (new_sorted_list[3],new_sorted_list[0],len(nodes)-1)
            
                elif len(node_list)==3: #if its a S3 element
                    k1=node_list.index(dis_edge_rev[0]-1)
                    k2=node_list.index(dis_edge_rev[1]-1)
                    new_sorted_list=[]
                    new_sorted_list.append(dis_edge_rev[0]-1)
                    new_sorted_list.append(dis_edge_rev[1]-1)
                    while len(new_sorted_list)<len(node_list):
                        if k2<len(node_list)-1: 
                            new_sorted_list.append(node_list[k2+1])
                            k2=k2+1
                        else:
                            new_sorted_list.append(node_list[0])
                            k2=0

                #come up with 2 new element connectivity for the current element
                    elements[neighbor_element]=(len(nodes)-1,new_sorted_list[1],new_sorted_list[2])
                    elements.append((new_sorted_list[2],new_sorted_list[0],len(nodes)-1))
                    
                    print (len(nodes)-1,new_sorted_list[1],new_sorted_list[2])
                    print (new_sorted_list[2],new_sorted_list[0],len(nodes)-1)
                    
                else:
                    print "Seems the element is invalid!"
            else:
                print "Seems the element is invalid!"
            
        node_coordinate.append(n)
        n1=n

    print des_vein_part_1
    print node_coordinate
    print des_vein_part_2

    vein_structures[mark]=des_vein_part_1+tuple(node_coordinate)+des_vein_part_2
    make_vein(vein_structures)
    pickle.dump(vein_structures,open(path+"point_list", "wb" ))
    pickle.dump(tuple(nodes),open( path+"node_data", "wb" ))    
    pickle.dump(elements,open( path+"element_data", "wb" )) 

        
#wrapper        
while(True):
    n1=input("First node: " )
    if (n1<1):
        break
    else:
        n2=input("Second node: ")

        repair_vein(n1,n2)

create_new_blade()
